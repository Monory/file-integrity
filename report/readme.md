# Integrity
## Отчёт о проделанной работе

Автор проекта - **Чудинов Никита**, группа *БПМИ145*.

### Решённые задачи

- Хеширование файов
- Хранение хешей в базе данных
- Проверка и хранение атрибутов файлов
- Поддержка регулярных выражений в конфигурационных файлах
- Регулярная проверка файлов на целостность по расписанию

### Технические проблемы и методы их решения
#### Хеширование файлов
Хеш-функции - это нетривиальные математические преобразования, которые весьма сложно полностью корректно и безошибочно реализовать человеку, не являющемуся специалистом в криптографии. Поэтому было решено использовать стороннюю библиотеку. В данном проекте я использовал широко распространённую библиотеку с открытым исходным кодом openssl.

openssl есть почти на всех компьютерах с Linux, поэтому её добавление в проект как зависимости фактически не приводит к усложнению процесса установки моей программы.

В качестве отрицательной стороны данной библиотеки я могу отметить краткость её документации, и, вследствие этого, сложность с изначальным внедрением её в проект, однако для достаточно несложных вещей это не должно занять много времени.

#### Хранение в базе данных
Для хранения хешей и прочей информации рассматривались разные варианты, такие как обычные текстовые файлы, какой-то более сложный бинарный формат или база данных. Так как мне хотелось сделать проект максимально простым в реализации, но, при этом, одновременно несложным для установки, я решил выбрать легковесную базу данных.

Моим ментором была предложена Berkeley DB, так же известная как BDB. BDB существует уже много лет и входит в базовую поставку почти всех дистрибутивов Linux, поэтому тоже не является тяжёлой зависимостью.

Berkeley DB, при этом, имеет родные библиотеки для работы с проектами на C++, поэтому добавление её в мой проект было тривиальной задачей. Она удобна в работе для небольших локальных проектов и при этом её использование упрощает проект, лишая необходимости делать свой формат хранения данных.

#### Проверка атрибутов файла
Атрибуты файла проверяются при помощи стандартной POSIX-функции `stat()`. Так как не все из них полезны при хранении (например, атрибут `st_atim`, возвращающий время последнего доступа к файлу, будет меняться при каждой проверке файла), было решено хранить данные в BDB обычной C-структурой, в которой будут только необходимые поля (включая, разумеется, и хеш файла).

#### Межпроцессное взаимодействие
Рассмотрев множество вариантов реализации межпроцессного взаимодействия (или IPC - interprocess communication), я решил использовать UNIX Sockets. Среди рассмотренных вариантов были:
- именованные каналы
- сокеты UNIX
- очереди POSIX
- общий файл
- разделяемая память

Сокеты UNIX были выбраны как достаточно мощный (позволяет нескольким клиентам общаться с демоном, позволяет простое двустороннее взаимодействие клиент-демон), но, при этом, простой в реализации вариант IPC.

#### Поддержка регулярных выражений
К моей большой радости, в одном из последних стандартов C++, а именно С++11, в стандартную библиотеку была добавлена библиотека регулярных выражений `std::regex`. Поэтому я воспользовался именно ей как самым простым и доступным вариантом.

#### Обход файловой системы
К сожалению, в стандартной библиотеке C++ нет удобного способа работы с файловой системой. Поэтому, моими вариантами было либо использование POSIX-интерфейса, либо использование сторонней библиотеки.

Оценив сложность необходимой работы, я решил использовать стороннюю библиотеку `boost::filesystem`. Boost - это один из старейших и наиболее качественных наборов библиотек для C++, и, как и прочие библиотеки, что я использую, так же уже установлен на многих компьютерах с Linux.

В качестве дополнительного замечания хотелось бы сказать, что `boost::filesystem` предложен к добавлению в C++ Standard Library Technical Report 2, то есть, возможно, в скором времени будет частью стандартной поставки компиляторов C++.

#### Поддержка конфигурационных файлов
Для разбора конфигурационных файлов было решено использовать `boost::property_tree`, так как я уже использую Boost в проекте.

В качестве формата конфигурационных файлов, было решено использовать .json, как более понятный и простой для написания, чем .xml, но при этом легко разбираемый программой и более однозначный и мощный, чем .ini.

#### Разбор аргументов командной строки
Изначально я опробовал использовать `boost::program_options`, но это ещё одна зависимость и при этом слишком мощная для моей задачи - для даже простых случаев приходилось писать очень много кода.

Поэтому я решил использовать более простой и доступный везде по умолчанию GNU `getopt`. `getopt_long()` поддерживает как длинные (`--store`), так и короткие (`-s`) аргументы командной строки, и, при этом, для не очень сложных случаев, позволяет кратко и ёмко написать обработчики для них.

#### Логирование
Для логирования я использовал библиотеку `plog`. Так как она мало распространена, но, при этом достаточно небольшая (меньше тысячи строк кода на C++), то было решено добавить её код непосредственно в репозиторий в качестве подключаемой библиотеки.
